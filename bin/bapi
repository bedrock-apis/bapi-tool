#!/usr/bin/env node

import { createCommand } from "commander";
import path from "node:path";
import ts from "typescript";

//#region rolldown:runtime
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", {
	value,
	configurable: true
});

//#endregion
//#region src/scan/index.ts
function createProgram(tsconfigPath) {
	tsconfigPath = path.resolve(tsconfigPath);
	console.log("Using", tsconfigPath);
	const config = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
	if (config.error) throw new Error("Errors parsing tsconfig:", { cause: config.error.messageText });
	const parsedConfig = ts.parseJsonConfigFileContent(config.config, ts.sys, path.resolve(path.dirname(tsconfigPath)));
	if (parsedConfig.errors.length) throw new Error("Errors parsing tsconfig:", { cause: parsedConfig.errors.map((e) => e.messageText) });
	console.log("Parsed config which includes", parsedConfig.fileNames.length, "files");
	const program = ts.createProgram(parsedConfig.fileNames, parsedConfig.options);
	return program;
}
function scanForSymbolsUsedIn(moduleNames, tsconfigPath, program = createProgram(tsconfigPath)) {
	const checker = program.getTypeChecker();
	console.log("Scanning for", moduleNames);
	const usedSymbols = {};
	const usedSymbolsByParent = {};
	const allSymbols = {};
	function visitModules(node) {
		if (ts.isIdentifier(node)) {
			const symbol = checker.getSymbolAtLocation(node);
			if (symbol) addSymbol(symbol, allSymbols, {});
		}
		ts.forEachChild(node, visitModules);
	}
	function visit(node) {
		if (ts.isImportDeclaration(node)) {
			const moduleSpecifier = node.moduleSpecifier;
			const moduleName = moduleSpecifier && ts.isStringLiteral(moduleSpecifier) && moduleSpecifier.text;
			if (moduleName && moduleNames.includes(moduleName)) visitImportClause(node);
		} else if (ts.isIdentifier(node)) {
			const symbol = checker.getSymbolAtLocation(node);
			if (symbol) addSymbol(symbol);
		}
		ts.forEachChild(node, visit);
	}
	for (const sourceFile of program.getSourceFiles()) {
		if (!sourceFile.isDeclarationFile) visit(sourceFile);
		const sourceDirname = path.dirname(sourceFile.fileName);
		for (const moduleName of moduleNames) if (sourceDirname.endsWith(moduleName)) visitModules(sourceFile);
	}
	return {
		symbols: usedSymbols,
		parent: usedSymbolsByParent,
		allSymbols
	};
	function addSymbol(symbol, to = usedSymbols, byParent = usedSymbolsByParent) {
		const declarations = symbol.getDeclarations();
		if (!declarations) return;
		if (!declarations.some((declaration) => {
			const fileName = declaration.getSourceFile().fileName;
			return moduleNames.some((e) => fileName.includes(e));
		})) return;
		const symbols = declarations.map((e) => {
			const sourceFileName = path.dirname(e.getSourceFile().fileName);
			const moduleName = moduleNames.find((moduleName$1) => sourceFileName.endsWith(moduleName$1));
			if (!moduleName) return;
			const parent = (ts.isClassDeclaration(e.parent) || ts.isEnumDeclaration(e.parent) || ts.isInterfaceDeclaration(e.parent)) && e.parent.name ? e.parent.name.getText() : false;
			if (!parent) console.log(e.parent.kind);
			return {
				parent,
				name: symbol.getName(),
				module: moduleName
			};
		}).filter((e) => !!e);
		for (const symbol$1 of symbols) {
			const parent = typeof symbol$1.parent === "string" ? symbol$1.parent : "global";
			byParent[symbol$1.module] ??= {};
			byParent[symbol$1.module][parent] ??= new Set();
			byParent[symbol$1.module][parent].add(symbol$1.name);
			to[symbol$1.module] ??= new Set();
			to[symbol$1.module].add(symbol$1.parent ? symbol$1.parent + "." + symbol$1.name : symbol$1.name);
		}
	}
	function visitImportClause(node) {
		if (!node.importClause?.namedBindings) return;
		const namedBindings = node.importClause.namedBindings;
		if (ts.isNamedImports(namedBindings)) namedBindings.elements.forEach((element) => {
			const symbol = checker.getSymbolAtLocation(element.name);
			if (symbol) addSymbol(symbol);
		});
		else {
			const symbol = checker.getSymbolAtLocation(namedBindings.name);
			if (symbol) addSymbol(symbol);
		}
	}
}
let ScanReportFormat = /* @__PURE__ */ function(ScanReportFormat$1) {
	ScanReportFormat$1["Json"] = "json";
	ScanReportFormat$1["Pretty"] = "pretty";
	return ScanReportFormat$1;
}({});

//#endregion
//#region src/cli/scan.ts
const scanSubcommand = createCommand("scan").description("Scans for ScriptAPI modules used in project").option("--tsconfig <string>", `path to your project's tsconfig.json or jsconfig.json file`).option("--modules [string[]]", `names of modules to be scanned separated by ,`, "@minecraft/server,@minecraft/server-ui,@minecraft/server-net,@minecraft/server-admin,@minecraft/common").option(`--format <${Object.values(ScanReportFormat).join("|")}>`, "Output format", ScanReportFormat.Json).action(({ tsconfig, modules, format }) => {
	if (!Object.values(ScanReportFormat).includes(format)) return console.error("Invalid format:", format);
	const report = scanForSymbolsUsedIn(modules.split(","), tsconfig);
	console.log(report.symbols);
	console.log("Total", Object.values(report.symbols).reduce((p, c) => c.size + p, 0));
	console.log(Object.entries(report.symbols).map((e) => e[0] + ": " + e[1].size + " " + (e[1].size / report.allSymbols[e[0]]?.size * 100).toFixed(0) + "%").join("\n"));
});

//#endregion
//#region src/cli/index.ts
createCommand("bapi").addCommand(scanSubcommand).parse();

//#endregion